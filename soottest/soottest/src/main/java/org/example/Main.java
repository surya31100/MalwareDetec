package org.example;

import java.util.Collections;
import javax.swing.text.View;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import sootup.core.jimple.basic.Value;
import sootup.core.jimple.common.stmt.Stmt;
import sootup.core.model.Body;
import sootup.core.inputlocation.AnalysisInputLocation;
import sootup.core.model.Method;
import sootup.core.model.SootClass;
import sootup.core.model.SootMethod;
import sootup.core.signatures.MethodSignature;
import sootup.core.types.ClassType;
import sootup.java.bytecode.inputlocation.JavaClassPathAnalysisInputLocation;
import sootup.java.core.JavaProject;
import sootup.java.core.JavaSootClass;
import sootup.java.core.JavaSootClassSource;
import sootup.java.core.language.JavaLanguage;
import sootup.java.core.views.JavaView;
import sootup.*;
import sootup.core.jimple.common.ref.JParameterRef;
import java.util.HashMap;

public class Main {

    public static void main(String args[]) {


        AnalysisInputLocation<JavaSootClass> inputLocation =
                new JavaClassPathAnalysisInputLocation("C:\\Users\\DELL\\Desktop\\testing soot");
        JavaLanguage language = new JavaLanguage(8);

        JavaProject project;
        project = JavaProject.builder(language)
                .addInputLocation(inputLocation).build();

        // Identify the test class and test method
        ClassType testClassType = project.getIdentifierFactory().getClassType("Factorial");
        MethodSignature testMethodSignature = project
                .getIdentifierFactory()
                .getMethodSignature(testClassType, "myTestMethod", "void", Collections.emptyList());

        JavaView view = project.createFullView();

        // Get the SootClass object for the test class
        SootClass<JavaSootClassSource> sootTestClass =
                (SootClass<JavaSootClassSource>) view.getClass(testClassType).get();

        // Get the SootMethod object for the test method
        SootMethod sootMethod = sootTestClass.getMethod(testMethodSignature.getSubSignature()).get();

        Body body = sootMethod.getBody();
        // Perform data flow analysis on the test method's body
       // HashMap<Stmt, HashSet<Value>> liveVariables = dataFlowAnalysis(body);

        // Analyze the live variables to identify dead code and common subexpressions
      //  for (Stmt stmt : body.getStmts()) {
        //    HashSet<Value> liveVars = liveVariables.get(stmt);
          //  if (liveVars == null) {
            //    System.out.println("Dead code detected at statement: " + stmt);
           // } else {
                // Analyze the live variables for common subexpressions
           // }
       // }

        System.out.println(sootMethod);
        System.out.println(sootMethod.getBody().getStmts());
        System.out.println(sootMethod.getBody().getLocalCount());

        dataFlowAnalysis(sootMethod.getBody());
    }

    private static HashMap<Stmt, HashSet<Value>> dataFlowAnalysis(Body body) {
        // Initialize data structures
        HashMap<Stmt, HashSet<Value>> liveVariables = new HashMap<>();
        for (Stmt stmt : body.getStmts()) {
            liveVariables.put(stmt, new HashSet<>());
        }

        // Perform forward data flow analysis
        boolean changed = true;
        int i=0;
        while (changed) {
            changed = false;
            for (Stmt stmt : body.getStmts()) {
                HashSet<Value> in = new HashSet<>();


                    in.addAll(liveVariables.get(stmt));

                i++;

                HashSet<Value> def = new HashSet<>();
                for (Value paramRef : stmt.getUses()) {
                    def.add(paramRef);
                }

                HashSet<Value> out = new HashSet<>(in);
                out.removeAll(def);
                out.addAll(stmt.getUses());

                if (!liveVariables.get(stmt).equals(out)) {
                    liveVariables.put(stmt, out);
                    changed = true;
                }
            }
        }

        return liveVariables;
    }

//*/
}
