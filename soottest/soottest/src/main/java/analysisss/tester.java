package analysisss;

import java.util.*;
import javax.swing.text.View;

import com.ibm.wala.fixedpoint.impl.Worklist;
import sootup.core.jimple.basic.Value;
import sootup.core.jimple.common.stmt.Stmt;
import sootup.core.model.Body;
import sootup.core.inputlocation.AnalysisInputLocation;
import sootup.core.model.Method;
import sootup.core.model.SootClass;
import sootup.core.model.SootMethod;
import sootup.core.signatures.MethodSignature;
import sootup.core.types.ClassType;
import sootup.java.bytecode.inputlocation.JavaClassPathAnalysisInputLocation;
import sootup.java.core.JavaProject;
import sootup.java.core.JavaSootClass;
import sootup.java.core.JavaSootClassSource;
import sootup.java.core.language.JavaLanguage;
import sootup.java.core.views.JavaView;
import sootup.*;
import sootup.core.jimple.common.ref.JParameterRef;


public class tester {
    public static void main(String args[])
    {

        AnalysisInputLocation<JavaSootClass> inputLocation =
                new JavaClassPathAnalysisInputLocation("C:\\Users\\DELL\\Desktop\\testing soot");
        JavaLanguage language = new JavaLanguage(8);

        JavaProject project;
        project = JavaProject.builder(language)
                .addInputLocation(inputLocation).build();

        ClassType classType =
                project.getIdentifierFactory().getClassType("Factorial");

        MethodSignature methodSignature =
                project
                        .getIdentifierFactory()
                        .getMethodSignature(
                                classType,"main", "void",
                                Collections.singletonList("java.lang.String[]"));

        JavaView view = project.createFullView();

        SootClass<JavaSootClassSource> sootClass =
                (SootClass<JavaSootClassSource>) view.getClass(classType).get();

        SootMethod sootMethod =
                sootClass.getMethod(methodSignature.getSubSignature()).get();

        sootMethod.getBody().getStmts();
        System.out.println(sootMethod);
        System.out.println(sootMethod.getBody().getStmts());
        System.out.println(sootMethod.getBody().getLocalCount());
        System.out.println(sootMethod.getBody().getLocals());
        //System.out.println(sootMethod.getBody().getLocalCount());



        LinkedList<Stmt> worklist = new LinkedList<>();
        for (Stmt i: sootMethod.getBody().getStmtGraph().getEntrypoints()) {
            //   System.out.println(sootMethod.getBody().getStmtGraph().getEntrypoints());
            worklist.add(i);
        }
        while (!worklist.isEmpty()) {
            Stmt method = worklist.poll();

            // Process the method (replace this with your specific analysis logic)
             processMethod(method);


        }
      //  Stmt method = (Stmt) sootMethod.getBody().getStmtGraph().getEntrypoints();
       // dfanalysis(method);
        // Perform data flow analysis on the `main` method
        /*
        engine.analyze(sootMethod);

        // Print the results of the analysis
        System.out.println("Data flow analysis results:");
        for (Definition definition : engine.getDefinitions()) {
            System.out.println(definition);
        }

         */

    }
    public static void processMethod(Stmt method) {
        LinkedList<Stmt> worklist = new LinkedList<>();
        HashSet<Stmt> processedStatements = new HashSet<>();

        for (Value successor : method.getUses()) {
            //System.out.println(successor);
            if (successor instanceof Stmt) {
                Stmt stmt = (Stmt) successor;

                if (!processedStatements.contains(stmt)) {
                    worklist.add(stmt);
                    processedStatements.add(stmt);
                    System.out.println("Added to worklist: " + stmt);
                }
                // } else if (successor instanceof JParameterRef) {
                // Handle JParameterRef objects here
                //   }
            }

            // Print the current worklist stack
            //System.out.println("Worklist stack:");
            for (Stmt stmt1 : worklist) {
                System.out.println(stmt1);
            }

            while (!worklist.isEmpty()) {
                Stmt nextMethod = worklist.poll();
                processMethod(nextMethod);
            }
        }
    }
/*
    public static void processMethod(Stmt method) {
        // Add the method's successors to the worklist
        LinkedList<Stmt> worklist = new LinkedList<>();
        for (Value successor : method.getUses()) {
            if (!worklist.contains(successor)) {
                worklist.add((Stmt) successor);
                System.out.println("Added to worklist: " + successor);
            }
        }

        // Print the current worklist stack
        System.out.println("Worklist stack:");
        for (Stmt stmt : worklist) {
            System.out.println(stmt);
        }
    }
    */

    //public static void processMethod(Stmt method) {
        // Implement your method processing logic here
        //System.out.println("Processing method: " + method.getName());

        // Example: Print the method's bytecode instructions
       // Body body = method.getBody();
       // for (Stmt unit1 : body.getStmts()) {
        //    System.out.println(unit1.toString());
       // }
  //  }
    /*
        public static void dfanalysis(Stmt method) {
            // Initialize data flow information
            HashMap<Stmt, HashSet<Value>> definitions = new HashMap<>();
            HashMap<Stmt, HashSet<Value>> uses = new HashMap<>();

            for (Stmt stmt : method.getDefs().getStmts()) {
                // Compute definitions for the current statement
                HashSet<Value> definedValues = new HashSet<>();
                if (stmt instanceof AssignStmt) {
                    AssignStmt assignStmt = (AssignStmt) stmt;
                    definedValues.add(assignStmt.getLeftOp());
                } else {
                    for (Value op : stmt.getOps()) {
                        definedValues.add(op);
                    }
                }
                definitions.put(stmt, definedValues);

                // Compute uses for the current statement
                Set<Value> usedValues = new HashSet<>();
                for (Value op : stmt.getUses()) {
                    usedValues.add(op);
                }
                uses.put(stmt, usedValues);
            }

            // Perform data flow analysis
            boolean changed = true;
            while (changed) {
                changed = false;

                for (Stmt stmt : method.getDefs().getStmts()) {
                    // Compute the new definitions for the current statement
                    Set<Value> newDefinitions = new HashSet<>();
                    for (Value definedValue : definitions.get(stmt)) {
                        newDefinitions.add(definedValue);
                    }

                    for (Value usedValue : uses.get(stmt)) {
                        newDefinitions.addAll(definitions.get(usedValue));
                    }

                    // Update the definitions if they have changed
                    Set<Value> oldDefinitions = definitions.get(stmt);
                    if (!oldDefinitions.equals(newDefinitions)) {
                        definitions.put(stmt, newDefinitions);
                        changed = true;
                    }

                    // Compute the new uses for the current statement
                    Set<Value> newUses = new HashSet<>();
                    for (Value usedValue : uses.get(stmt)) {
                        newUses.addAll(uses.get(usedValue));
                    }

                    // Update the uses if they have changed
                    Set<Value> oldUses = uses.get(stmt);
                    if (!oldUses.equals(newUses)) {
                        uses.put(stmt, newUses);
                        changed = true;
                    }
                }
            }

            // Print the data flow information
            System.out.println("Definitions:");
            for (Map.Entry<Stmt, Set<Value>> entry : definitions.entrySet()) {
                System.out.println(entry.getKey() + ": " + entry.getValue());
            }

            System.out.println("Uses:");
            for (Map.Entry<Stmt, Set<Value>> entry : uses.entrySet()) {
                System.out.println(entry.getKey() + ": " + entry.getValue());
            }
        }

*/
}
